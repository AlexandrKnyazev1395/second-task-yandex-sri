# Приложение для создания и редактирования информации о встречах сотрудников. 2-ое задание

## Задание
Сверстать по данному макету.

## Запуск
```
npm i
npm start
```

## Стек технологий
В ходе выполнения задания для создания компонентов части были использованы React + Redux, стили написаны на чистом css.

## Дневник разработчика

### Выбор технологий
За свою небольшую карьеру в качестве веб-разработчика мне приходилось разрабатывать клиентскую часть сайтов на `html+css+javascript+Jquery` и на `React`. Поэтому особо сложного решения в выборе технологий для меня не было, я выбрал React.js

Наулучшее, по моему опыту, решение для быстрого старта и удобной разработки - `Create React App`. Мне помогли идущие с ним из коробки модули, loaders и т.д. Очень удобно, что не нужно тратить время на настраивание Webpack.

### Способы организации 

#### Стили
На начальном этапе разработки я не удалели должного внимания способу организации css, что привело к дублированию классов в различных местах. Затем я прочитал про БЭМ, но использовать его не стал, так как в рамках данного небольшого проекта я посчитал это слишком сложным. Я решил просто использовать те же класссы, только перед каждым классом в css уточнять родительские компоненты. Безусловно, мне нужно будет изучить различные способы организации стилей и придерживаться одной из них в будущем.

#### Компоненты
Способов организации структуры react-компонентов существует немало. У каждого есть свои минусы:

При иерархическом подходе ты получаешь логичную структуру файлов, приближенную к бизнес-логике, но приходится забыть о повторном использовании компонентов и включать очень длинные цепочки './../../...'  в import. 
При создании более плоской файловой структуры довольно сложной становится навигация по проекту.

Разбиение всех компонентов на containers и components - довольно удачное решение, если научиться правильно относить компонент к одному из двух видов.
 
Т.к. в нашем приложении компоненты преимущественно различаются, нам не стоит беспокоиться о проблеме их повторного использования. Также проблема излишней вложенности не стоит остро благодаря испоьзованию Redux (мы имеем доступ к глобальному хранилищу из любого компонента) . Поэтому я решил использовать более понятную для глаза иерархическую структуру компонентов.

### Главные проблемы, с которыми пришлось столкнуться во время верстки

### Сетка
Создание сетки ожидаемо стало для меня самой сложной задачей в данном задании. То, что на первый взгляд, кажется таблицей, как оказывается, совсем ей не является. После несколькиз неудачных попыток родилась работающая идея: 
Расписание представляет из себя две css-grid колонки, каждая имеет ширину `100% экрана`. Но  правая колонка сдвигается влево на ширину `100%  - ширина левой колонки`. Правая колонка - это расчерченная вертикальными линиями сетка, а левая включает в себя этажы, их комнаты и проводящиеся в них events. Расписание events накладывается на сетку.
Главное условие для реализации этой идеи мы должны при расчете нескольких css-свойств знать ширину левой колонки. Поэтому я задал ее в css-переменной.

### Закрепление шапки, выбора даты и названий комнат при горизонтальном скролле
Вначале я вешал событие на scroll страницы и при каждом срабатывании этого события сдвигал блоки на колическтво проскролленных пикселей. Как оказалось, это работает хорошо только на PC. Мой android имеет проблемы с отрисовкой подобной анимации.  Я вышел из ситуации так: 
 - шапка имеет position: fixed и самый маленький z-index, при вертикальном скролле она просто скрывается за другими элементами.
 - выбор даты имеет position fixed на мобильных экранах и при скролле вниз на него повешено событие смещения вверх на высоту шапки. Т.о. блок становится на место, где была шапка при вертикальном скролле.
 - к сожалению, в случае с названиями комнат я не смог придумать ничего для улучшения производительности. Я лишь добавил transition-duration,чтобы смещение проходило плавнее.

 

Идем в документацию Sequalize и видим, что **на вход в конструктор должно подаваться три аргумента, затем уже опции, а в текущей реализации их передается лишь два.** Принимаем судьбоносное решение - добавляем аргумент password (еще один null). Приложение запускается. 


Первый route "/" работает, пробуем перейти на "/graphql", и видим ошибку 404. Странно, ведь route для graphql объявлен. Пристально изучаем [./graphql/routes/](./graphql/routes), не видя ничего криминального идем перечитывать документацию express, не находим отличий с текущей реализацией. Смотрим на каждую строчку еще пристальнее. Ага, **опечатка**, вместо graphql написано graphgl. Смеемся с собственной невнимательности, идем попить чайку.

Во время чайной паузы в нас просыпается эстет и мы решаем, что проект, на который тратится больше получаса, не может существовать без config-файла. Добавляем config.js, в нем указываем порт для запуска и папку для статических файлов.

Давно хотел познакомится с GraphQL. Идем читать доки. Когда начинаем что-то понимать, переходим к тестированию запросов.


Ошибка №1 появляется при попытке получить Events. Идем в [./graphql/resolvers/query.js](./graphql/resolvers/query.js), фиксим **ошибку с передачей аргумента**, заодно форматируем код. Не вручную, конечно, просто жмем Ctrl+Shift+I в VS Code.

Теперь запрос events работает, но не полностью: **users и room - пустые значения**, хотя в БД они есть. Идем в [./graphql/resolvers/index.js](./graphql/resolvers/index.js), добавляем return'ы в Event-users и Event-room.

Ошибка №2 - не работает функция добавления User  в Event. Заходим в [graphql/resolvers/mutation.js] (graphql/resolvers/mutation.js), видим что там и **не описана эта функция**. Добавляем ее. Профит.

Ошибка №3 - функция changeEventRoom работает, но **не возвращает ничего в graphql sandbox**. Добавляем в функцию return event.

Ошибка №4 - **Не работает должным образом обновление** User, Event и Room, т.к. для обновления используются те же input types, что и для создания. Соответственно, чтобы обновить одно из полей, в input нужно указать все обязательные поля. Разделяем UserInput на UserCreateInput и UserUpdateInput, для других коллекций - аналогично.

Ошибка №5 - **ненужный тип UserRoom**. Выпиливаем его.

Ошибка №6 - **при создании User мы не можем добавить avatarUrl**, так как его нет в схеме. Добавляем.

На этом задание можно считать оконченным, т.к. все запросы проходят успешно.
В идеале в папку со скриптами нужно добавить serviceWorker.js, т.к. браузер пытается найти его в папке public, но не находит.Постараюсь добавить после выполнения следующих заданий.


